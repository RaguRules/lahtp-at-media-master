<?php
/**
 * Happens in Init.php, the web app is getting initialized.
 */
class WebAPI {

	/**
	 * Original database connection client
	 * @var MongoDB/Client
	 */
	private $mongoClient;

	/**
	 * Constructs the entire WebApp. This is where it all begins.
	 */
	function __construct() {
		if(!extension_loaded('mongodb')){
			die('Requirements unsatisfied');
		}
		try {
			$this->mongoClient = new MongoDB\Client("mongodb://db.aftertutor.com:27017");
			if (!$this->mongoClient) {
				//TODO: Inform status site about failure
				http_response_code(500);
				die("Database server not running. Try running 'mongod' from you CLI and get back here.");
			}
			$build = '';
			$cacheCDN = '';
			if (isset($_SERVER['HTTP_HOST'])) {
				if ($_SERVER['HTTP_HOST'] == 'upload.aftertutor.com') {
					$build = 'prod';
					Session::set('php', exec('which php'));
				} else if ($_SERVER['HTTP_HOST'] == 'medialocal.aftertutor.com') {
					$build = 'local';
					Session::set('php', "/usr/local/opt/php@7.1/bin/php");
				} else {
					throw new UnsupportedDomainException;
					die();
				}
			}
			Session::$environment = $build;
			Session::$cacheCDN = $cacheCDN;
			$git = new QuickGit($build);
			Session::$version = $git->getShort();
			Session::$localPack = array();
		} catch (MongoDB\Driver\Exception\ConnectionTimeoutException $e) {
			//TODO: Inform status site about failure
			http_response_code(500);
			die("Database server not running. Try running 'mongod' from your CLI and get back here.");
		}
	}

	/**
	 * During the Init, after construction, the Default mongoclient will be assigned to the DatabaseConnection::$client.
	 * @return MongoDB/Client
	 */
	function getDatabaseClient() {
		return $this->mongoClient;
	}

	/**
	 * Takes an intrator or object, and converts it into an Array.
	 * @param  Any $obj
	 * @return Array
	 */
	public static function purifyArray($obj) {
		return json_decode(json_encode($obj), true);
	}

	/**
	 * Returns the password hash for a provided value. Can be used to check or validate the hash at any point against the value using the password_verify method.
	 * @param  String  $value The string that has to be hashed
	 * @param  integer $cost  The cost parameter of the hash (Maximum value means more secure)
	 * @return String         The password has will be returned, generated by password_hash method.
	 */
	public static function hash($value, $cost = 4) {
		//cost should be greater than or equal to 4
		if ($cost <= 3) {
			throw new Exception('Invalid Cost Parameter');
		}
		$options = [
			'cost' => $cost, //profiled for less than 10 milliseconds
			];
			$pref = "";
			if ($cost <= 9) {
				$pref = 0;
			}
			return password_hash($value, PASSWORD_DEFAULT, $options);
		}

	/**
	 * A general method used to ger the string between two index locations.
	 * @param  String $string
	 * @param  Integer $start
	 * @param  Integer $end
	 * @return String         The sliced string.
	 */
	public static function get_string_between($string, $start, $end) {
		$string = ' ' . $string;
		$ini = strpos($string, $start);
		if ($ini == 0) {
			return '';
		}

		$ini += strlen($start);
		$len = strpos($string, $end, $ini) - $ini;
		return substr($string, $ini, $len);
	}

	public static function startsWith($haystack, $needle) {
		$length = strlen($needle);
		return (substr($haystack, 0, $length) === $needle);
	}

	public static function endsWith($haystack, $needle) {
		$length = strlen($needle);
		if ($length == 0) {
			return true;
		}

		return (substr($haystack, -$length) === $needle);
	}

	public static function contains($haystack, $needle) {
		return strpos($haystack, $needle) !== false;
	}

	public static function formatNum($num, $precision = 0) {
		if ($num >= 1000 && $num < 1000000) {
			$n_format = number_format($num/1000,$precision).'K';
		} else if ($num >= 1000000 && $num < 1000000000) {
			$n_format = number_format($num/1000000,$precision).'M';
		} else if ($num >= 1000000000) {
			$n_format=number_format($num/1000000000,$precision).'B';
		} else {
			$n_format = $num;
		}
		return $n_format;
	}

}
